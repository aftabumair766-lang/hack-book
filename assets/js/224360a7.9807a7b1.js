"use strict";(self.webpackChunkhack_book=self.webpackChunkhack_book||[]).push([[474],{7487:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"chapter-01/kinematics-dynamics","title":"Kinematics and Dynamics","description":"Mathematical foundations of robot motion: kinematics and dynamics","source":"@site/docs/chapter-01/kinematics-dynamics.md","sourceDirName":"chapter-01","slug":"/chapter-01/kinematics-dynamics","permalink":"/hack-book/docs/chapter-01/kinematics-dynamics","draft":false,"unlisted":false,"editUrl":"https://github.com/aftabumair766-lang/hack-book/tree/main/docs/chapter-01/kinematics-dynamics.md","tags":[],"version":"current","frontMatter":{"id":"kinematics-dynamics","title":"Kinematics and Dynamics","description":"Mathematical foundations of robot motion: kinematics and dynamics","section_number":"1.3"},"sidebar":"coursebookSidebar","previous":{"title":"Sensors and Actuators","permalink":"/hack-book/docs/chapter-01/sensors-actuators"},"next":{"title":"Chapter 1 Exercises","permalink":"/hack-book/docs/chapter-01/exercises"}}');var r=i(4848),t=i(8453);const a={id:"kinematics-dynamics",title:"Kinematics and Dynamics",description:"Mathematical foundations of robot motion: kinematics and dynamics",section_number:"1.3"},o="1.3 Kinematics and Dynamics",c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Kinematics Fundamentals",id:"kinematics-fundamentals",level:2},{value:"Forward Kinematics",id:"forward-kinematics",level:3},{value:"Denavit-Hartenberg (DH) Parameters",id:"denavit-hartenberg-dh-parameters",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:3},{value:"Dynamics Fundamentals",id:"dynamics-fundamentals",level:2},{value:"Newton-Euler Equations",id:"newton-euler-equations",level:3},{value:"Joint Torques",id:"joint-torques",level:3},{value:"Mass and Inertia Effects",id:"mass-and-inertia-effects",level:3},{value:"Workspace Analysis",id:"workspace-analysis",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function d(n){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"13-kinematics-and-dynamics",children:"1.3 Kinematics and Dynamics"})}),"\n",(0,r.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Kinematics"})," describes robot motion geometry (positions, velocities) without considering forces.\r\n",(0,r.jsx)(e.strong,{children:"Dynamics"})," includes forces and torques that cause motion."]}),"\n",(0,r.jsx)(e.h2,{id:"kinematics-fundamentals",children:"Kinematics Fundamentals"}),"\n",(0,r.jsx)(e.h3,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Problem"}),": Given joint angles, find end-effector position."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"2-DOF Planar Arm Example"}),":"]}),"\n",(0,r.jsx)(e.p,{children:"$$\r\nx = L_1 \\cos(\\theta_1) + L_2 \\cos(\\theta_1 + \\theta_2)\r\n$$"}),"\n",(0,r.jsx)(e.p,{children:"$$\r\ny = L_1 \\sin(\\theta_1) + L_2 \\sin(\\theta_1 + \\theta_2)\r\n$$"}),"\n",(0,r.jsx)(e.p,{children:"Where:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"L\u2081, L\u2082 = link lengths"}),"\n",(0,r.jsx)(e.li,{children:"\u03b8\u2081, \u03b8\u2082 = joint angles"}),"\n",(0,r.jsx)(e.li,{children:"(x, y) = end-effector position"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Python Example"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'import numpy as np\r\n\r\ndef forward_kinematics_2dof(theta1, theta2, L1, L2):\r\n    """Calculate end-effector position for 2-DOF planar arm."""\r\n    x = L1 * np.cos(theta1) + L2 * np.cos(theta1 + theta2)\r\n    y = L1 * np.sin(theta1) + L2 * np.sin(theta1 + theta2)\r\n    return (x, y)\r\n\r\n# Example usage\r\ntheta1 = np.pi / 4  # 45 degrees\r\ntheta2 = np.pi / 6  # 30 degrees\r\nL1, L2 = 1.0, 0.8   # meters\r\n\r\npos = forward_kinematics_2dof(theta1, theta2, L1, L2)\r\nprint(f"End-effector: ({pos[0]:.3f}, {pos[1]:.3f}) m")\r\n# Output: (1.532, 1.207) m\n'})}),"\n",(0,r.jsx)(e.h3,{id:"denavit-hartenberg-dh-parameters",children:"Denavit-Hartenberg (DH) Parameters"}),"\n",(0,r.jsx)(e.p,{children:"A standard convention for describing robot kinematics with 4 parameters per link:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"a = link length"}),"\n",(0,r.jsx)(e.li,{children:"\u03b1 = link twist"}),"\n",(0,r.jsx)(e.li,{children:"d = link offset"}),"\n",(0,r.jsx)(e.li,{children:"\u03b8 = joint angle"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"(Full DH derivation covered in advanced courses)"}),"\n",(0,r.jsx)(e.h3,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Problem"}),": Given desired end-effector position, find joint angles."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Challenges"}),":"]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Multiple solutions"}),": Same position, different joint configurations"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"No solution"}),": Position outside reachable workspace"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Singularities"}),": Infinite solutions or loss of DOF"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Solution methods"}),": Analytical (closed-form), numerical (iterative)"]}),"\n",(0,r.jsx)(e.h2,{id:"dynamics-fundamentals",children:"Dynamics Fundamentals"}),"\n",(0,r.jsx)(e.h3,{id:"newton-euler-equations",children:"Newton-Euler Equations"}),"\n",(0,r.jsx)(e.p,{children:"Robot dynamics governed by Newton's laws:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"\u03c4 = I \xd7 \u03b1 + (other forces)\n"})}),"\n",(0,r.jsx)(e.p,{children:"Where:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"\u03c4 (tau) = joint torque"}),"\n",(0,r.jsx)(e.li,{children:"I = moment of inertia"}),"\n",(0,r.jsx)(e.li,{children:"\u03b1 (alpha) = angular acceleration"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"joint-torques",children:"Joint Torques"}),"\n",(0,r.jsx)(e.p,{children:"To move a robot link, motors must provide torque to:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Overcome gravity (weight of links)"}),"\n",(0,r.jsx)(e.li,{children:"Accelerate links (inertial forces)"}),"\n",(0,r.jsx)(e.li,{children:"Overcome friction"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"mass-and-inertia-effects",children:"Mass and Inertia Effects"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Heavier links"})," require more torque to accelerate"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Distribution of mass"})," affects rotational inertia"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Payload"})," (carried object) changes dynamics"]}),"\n",(0,r.jsx)(e.li,{children:"Controllers must account for these effects for smooth motion"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"workspace-analysis",children:"Workspace Analysis"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Workspace"}),": Set of all reachable positions for the end-effector."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Types"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Reachable workspace"}),": All positions the end-effector can reach"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Dexterous workspace"}),": Positions reachable with any orientation"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Factors"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Link lengths"}),"\n",(0,r.jsx)(e.li,{children:"Joint limits (mechanical constraints)"}),"\n",(0,r.jsx)(e.li,{children:"Singularities (lose degrees of freedom)"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsx)(e.admonition,{title:"Key Points",type:"tip",children:(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Forward kinematics"}),": Joint angles \u2192 End-effector position (straightforward)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Inverse kinematics"}),": End-effector position \u2192 Joint angles (challenging)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"DH parameters"}),": Standard way to describe robot kinematics"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Dynamics"}),": Accounts for forces, torques, mass, inertia"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Singularities"}),": Configurations where robot loses DOF"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Workspace"}),": Set of all positions robot can reach"]}),"\n"]})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Previous"}),": ",(0,r.jsx)(e.a,{href:"/hack-book/docs/chapter-01/sensors-actuators",children:"Sensors and Actuators"})," | ",(0,r.jsx)(e.strong,{children:"Next"}),": ",(0,r.jsx)(e.a,{href:"/hack-book/docs/chapter-01/exercises",children:"Exercises"})]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>o});var s=i(6540);const r={},t=s.createContext(r);function a(n){const e=s.useContext(t);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),s.createElement(t.Provider,{value:e},n.children)}}}]);